## 13549. 숨바꼭질3

<br>

#### 001. 첫 번째 풀이

> BFS를 활용하여 조건에 맞는 위치(왼쪽, 오른쪽, 순간이동)를 탐색하는 방식으로 코드를 작성하였다. 그리고 이제부터 기능별 분리에 조금 더 집착해보려고 한다. 아! BFS로 풀었기 때문에 순서에 유의해야 하는데, 가중치가 가장 작은 방식인 순간이동의 위치를 먼저 탐색해야 한다. (BFS는 가중치가 동일한 상황에서만 일정한 답을 보장)

<br>

```python
import sys
from collections import deque


def check_validation(node, visited):
    return 0 <= node < 100001 and not visited[node]


def find_target(start, target):
    visited = [False] * 100001
    visited[start] = True
    q = deque([(start, 0)])

    while q:
        start, time = q.popleft()
        if start == target:
            return time

        left, right, jump = start - 1, start + 1, start * 2
        if check_validation(jump, visited):
            visited[jump] = True
            q.appendleft((jump, time))
        if check_validation(left, visited):
            visited[left] = True
            q.append((left, time+1))
        if check_validation(right, visited):
            visited[right] = True
            q.append((right, time+1))


n, k = map(int, sys.stdin.readline().split())
print(find_target(n, k))
```

